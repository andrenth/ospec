                               ospec
                               ~~~~~

1. INTRODUCTION
---------------

OSpec is a Behavior-Driven Development library for OCaml, inspired by RSpec, a
Ruby BDD library. It is implemented as a Camlp4 syntax extension.

This is a work in progress and should be considered beta quality.

Note: OSpec requires OCaml >= 3.10.0 to run. On versions below 3.11.0, though,
there are two limitations:

* If you want to use helpers in your specifications (see below), you must
  explicitely "open Helpers" at the top of every specification file.

* Running the "ospec" command with multiple files as arguments doesn't work.


2. USAGE
--------

To build and install OSpec, simply type

  $ make
  # make install

These commands (and OSpec itself) rely on findlib, so you need to have it
installed for them to work. An executable called "ospec" which takes
specification files as command line arguments will be build. For example, the
command below will run the specifications in the file specs.ml:

  $ ospec specs.ml

The default report format is "nested". You can choose the format from the
command line using the "-format" option. Currently the available formats are
"nested" and "progress".


3. SYNTAX
---------

Specifications are defined with the "describe" keyword. Inside a specification,
examples are defined, with the "it" keyword, including one or more expectations.
Expectations are tests comparing some result to an expected value using the
"should" keyword.

OSpec also supports "before" and "after" blocks, which can be used to run
code before or after running the examples. This is only useful for operations
which cause side-effects on some global variable (see examples/hooks.ml).
Defining a variable in a "before" block doesn't make it available for the
examples, since the scope of such a variable would be the "before" block
itself.

Here's useless specification which shows how OSpec's syntax works:

  describe "The number one" do
    before all do
      (* Code here runs once, before all examples. *)
    done;

    before each do
      (* Code here runs before each example. *)
    done;

    after each do
      (* Code here runs after each example. *)
    done;

    after all do
      (* Code here runs once, after all examples. *)
    done;

    it "should equal 2 when added to itself" do
      (1 + 1) should = 2  (* anything 'a -> 'a -> bool should work *)
    done;

    it "should be positive" do
      let positive x = x > 0 in
      1 should be positive  (* 'a -> bool should work too *)
    done;

    it "should be negative when multiplied by -1" do
      let x = 1 * (-1) in
      x should be < 0;      (* "be" is optional *)
      x should not be >= 0
    done;

    it "should fail when divided by 0" do
      (* For exception tests, wrap it in a fun *)
      let f = fun () -> 1 / 0 in
      f should raise_an_exception;
      f should raise_exception Division_by_zero;
      f should not raise Exit
    done;

    it "should match ^[0-9]+$ when converted to a string" do
      (string_of_int 1) should match_regexp "^[0-9]+$"
    done;

    (* Specify behaviors still not implemented like this *)
    it "should be cool"
  done


4. HELPERS
----------

Some helper functions are provided, as shown above. They are described below.

val raise_an_exception : (unit -> 'a) -> bool
  Returns true if any exception is raised

val raise_exception : (unit -> 'a) -> exn -> bool
  Returns true if the given exception is raised

val match_regexp : string -> string -> bool
  Returns true if the given string (first argument) matches the given regex
  (second argument).


5. TODO
-------

* Handle errors in the specs gracefully.
* Allow nested specs.
* Provide more report formats.
* Provide more helpers.
* Cleanup the code, which is horrible and hacky.
* ...
