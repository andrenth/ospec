                               ospec
                               ~~~~~

1. INTRODUCTION
---------------

OSpec is a Behavior-Driven Development library for OCaml, inspired by RSpec, a
Ruby BDD library. It is implemented as a Camlp4 syntax extension.

This is a work in progress and should be considered less-than-alpha quality.


2. USAGE
--------

To build OSpec, simply type "make". This will build an executable called
"ospec", which takes specification files as command line arguments.  For
example, the command below will run the specifications in the file specs.ml:

  $ ./ospec specs.ml


3. SYNTAX
---------

Specifications are defined with the "describe" keyword. Inside a specification,
examples are defined, with the "it" keyword, including one or more expectations.
Expectations are tests comparing some result to an expected value using the
"should" keyword.

OSpec also supports "before" and "after" blocks, which can be used to run
code before or after running the examples. This is only useful for operations
which cause side-effects on some global variable (see examples/hooks.ml).
Defining a variable in a "before" block doesn't make it available for the
examples, since the scope of such a variable would be the "before" block
itself.

Here's useless specification which shows how OSpec's syntax works:

  describe "The number one" do
    before all do
      (* Code here runs once, before all examples. *)
    done;

    before each do
      (* Code here runs before each example. *)
    done;

    after each do
      (* Code here runs after each example. *)
    done;

    after all do
      (* Code here runs once, after all examples. *)
    done;

    it "should equal 2 when added to itself" do
      (1 + 1) should = 2  (* anything 'a -> 'a -> bool should work *)
    done;

    it "should be positive" do
      let positive x = x > 0 in
      1 should be positive  (* 'a -> bool should work too *)
    done;

    it "should be negative when multiplied by -1" do
      let x = 1 * (-1) in
      x should be < 0;      (* "be" is optional *)
      x should not be >= 0
    done;

    it "should fail when divided by 0" do
      (* For exception tests, wrap it in a fun *)
      let f = fun () -> 1 / 0 in
      f should raise_an_exception;
      f should raise_exception Division_by_zero;
      f should not raise Exit
    done;

    it "should match ^[0-9]+$ when converted to a string" do
      (string_of_int 1) should match_regexp "^[0-9]+$"
    done;

    (* Specify behaviors still not implemented like this *)
    it "should be cool"
  done


4. HELPERS
----------

Some helper functions are provided, as shown above. They are described below.

val raise_an_exception : (unit -> 'a) -> bool
  Returns true if any exception is raised

val raise_exception : (unit -> 'a) -> exn -> bool
  Returns true if the given exception is raised

val match_regexp : string -> string -> bool
  Returns true if the given string (first argument) matches the given regex
  (second argument).


5. TODO
-------

* Handle errors in the specs gracefully.
* Allow nested specs.
* Provide different report formats.
* Provide more helpers.
* Cleanup the code, which is horrible and hacky.
* ...
